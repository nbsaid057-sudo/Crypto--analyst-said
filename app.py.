import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import requests, feedparser, urllib.parse
import yfinance as yf

st.set_page_config(page_title="Crypto Analyst ‚Äì Sa√Ød (Simple)", layout="wide")
st.title("üß† Crypto Analyst ‚Äì Sa√Ød")
st.caption("Version simple. Analyse SR, Ichimoku, RSI, plan Entr√©e/TP/SL + alertes + actus.")

PRESETS = {
    "XRP (H4)": {"symbol": "XRP","source": "auto","tf": "4h","history_days": 180,"limit": 500,
        "alerts": {"price_up": 3.10,"price_down": 2.40,"rsi_over_enabled": True,"rsi_over": 70,
                   "rsi_under_enabled": True,"rsi_under": 35,"sr_cross_enabled": True}},
    "SOL (H4)": {"symbol": "SOL","source": "auto","tf": "4h","history_days": 180,"limit": 500,
        "alerts": {"price_up": 220.0,"price_down": 160.0,"rsi_over_enabled": True,"rsi_over": 70,
                   "rsi_under_enabled": True,"rsi_under": 35,"sr_cross_enabled": True}}
}

def _to_df(klines):
    cols = ['Open time','Open','High','Low','Close','Volume','Close time','Quote asset vol','Trades','Taker buy base','Taker buy quote','Ignore']
    df = pd.DataFrame(klines, columns=cols)
    for c in ['Open','High','Low','Close','Volume']: df[c] = df[c].astype(float)
    df['Open time'] = pd.to_datetime(df['Open time'], unit='ms')
    return df.rename(columns={'Open time':'Date'})[['Date','Open','High','Low','Close','Volume']].set_index('Date')

def load_from_binance(symbol, interval="1h", limit=500):
    sym = symbol.upper().replace("-","");  sym = sym if sym.endswith("USDT") else sym+"USDT"
    r = requests.get(f"https://api.binance.com/api/v3/klines?symbol={sym}&interval={interval}&limit={int(limit)}", timeout=15)
    r.raise_for_status(); data = r.json()
    if isinstance(data, dict) and 'code' in data: raise RuntimeError(str(data))
    return _to_df(data)

def load_from_mexc(symbol, interval="1h", limit=500):
    sym = symbol.upper().replace("-","");  sym = sym if sym.endswith("USDT") else sym+"USDT"
    r = requests.get(f"https://api.mexc.com/api/v3/klines?symbol={sym}&interval={interval}&limit={int(limit)}", timeout=15)
    r.raise_for_status(); data = r.json()
    if isinstance(data, dict) and data.get('code') not in (None, '200'): raise RuntimeError(str(data))
    return _to_df(data)

def load_from_yahoo(symbol, interval="60m", period_days=180):
    ticker = symbol.upper();  ticker = ticker if "-" in ticker else f"{ticker}-USD"
    data = yf.download(ticker, period=f"{period_days}d", interval=interval, progress=False, auto_adjust=False)
    if data is None or data.empty: raise RuntimeError("Yahoo Finance: aucun historique trouv√©.")
    data = data.rename(columns=str.title); data.index.name = "Date"
    return data[['Open','High','Low','Close','Volume']]

def load_ohlc(symbol, source, interval, limit=500, period_days=180):
    if source == "auto":
        for src in ["binance","mexc","yahoo"]:
            try:
                if src == "binance": return load_from_binance(symbol, interval, limit), "binance"
                if src == "mexc": return load_from_mexc(symbol, interval, limit), "mexc"
                iv = "60m" if interval.endswith("h") else ("1d" if interval.endswith("d") else "60m")
                return load_from_yahoo(symbol, iv, period_days), "yahoo"
            except Exception:
                continue
        raise RuntimeError("Aucune source n‚Äôa pu fournir des donn√©es OHLC.")
    if source == "binance": return load_from_binance(symbol, interval, limit), "binance"
    if source == "mexc": return load_from_mexc(symbol, interval, limit), "mexc"
    if source == "yahoo":
        iv = "60m" if interval.endswith("h") else ("1d" if interval.endswith("d") else "60m")
        return load_from_yahoo(symbol, iv, period_days), "yahoo"
    raise ValueError("Source inconnue.")

def rsi(series, period=14):
    delta = series.diff(); up = delta.clip(lower=0); down = -1 * delta.clip(upper=0)
    roll_up = up.ewm(alpha=1/period, adjust=False).mean(); roll_down = down.ewm(alpha=1/period, adjust=False).mean()
    rs = roll_up / (roll_down.replace(0, np.nan));  return 100 - (100 / (1 + rs))

def ichimoku(df, conv_period=9, base_period=26, span_b_period=52, displacement=26):
    high, low, close = df['High'], df['Low'], df['Close']
    tenkan = (high.rolling(conv_period).max() + low.rolling(conv_period).min()) / 2
    kijun  = (high.rolling(base_period).max() + low.rolling(base_period).min()) / 2
    span_a = ((tenkan + kijun) / 2).shift(displacement)
    span_b = ((high.rolling(span_b_period).max() + low.rolling(span_b_period).min()) / 2).shift(displacement)
    chikou = close.shift(-displacement)
    return pd.DataFrame({'tenkan':tenkan,'kijun':kijun,'span_a':span_a,'span_b':span_b,'chikou':chikou}, index=df.index)

def swing_points(df, window=3):
    highs = (df['High'].rolling(window*2+1, center=True).apply(lambda x: float(x[window] == x.max()), raw=False))
    lows  = (df['Low'].rolling(window*2+1, center=True).apply(lambda x: float(x[window] == x.min()),  raw=False))
    hi = highs.fillna(0).astype(bool); lo = lows.fillna(0).astype(bool)
    return df.loc[hi, 'High'], df.loc[lo, 'Low']

def cluster_levels(levels, px_tol=None):
    lv = levels.dropna().values
    if lv.size == 0: return []
    med = np.median(lv); px_tol = px_tol or med * 0.0025
    lv_sorted = np.sort(lv); clusters = [[lv_sorted[0]]]
    for v in lv_sorted[1:]:
        if abs(v - np.mean(clusters[-1])) <= px_tol: clusters[-1].append(v)
        else: clusters.append([v])
    return sorted([float(np.mean(c)) for c in clusters])

def sr_bands_from_swings(df, window=3, px_tol=None):
    sh, sl = swing_points(df, window=window)
    return cluster_levels(sl, px_tol), cluster_levels(sh, px_tol)

def generate_plan(latest_price, supports, resist
